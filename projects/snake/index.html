<!DOCTYPE html>
<html lang="pl" data-theme="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Snake — Kacper</title>
    <style>
        :root[data-theme="dark"] {
            --bg: #0f0f1a;
            --bg-card: #1a1a2e;
            --bg-input: #16213e;
            --border: #2a2a4a;
            --text: #e0e0e0;
            --text-muted: #8888aa;
            --accent: #6c5ce7;
            --accent-hover: #a29bfe;
            --toggle-bg: #2a2a4a;
            --shadow: rgba(0,0,0,0.3);
            --canvas-bg: #12122a;
            --grid-line: rgba(255,255,255,0.03);
            --snake-head: #6c5ce7;
            --snake-body: #a29bfe;
            --food-color: #ff6b6b;
        }
        :root[data-theme="light"] {
            --bg: #f0f2f5;
            --bg-card: #ffffff;
            --bg-input: #f8f9fa;
            --border: #ddd;
            --text: #1a1a2e;
            --text-muted: #666;
            --accent: #6c5ce7;
            --accent-hover: #5a4bd1;
            --toggle-bg: #ddd;
            --shadow: rgba(0,0,0,0.1);
            --canvas-bg: #e8e8f0;
            --grid-line: rgba(0,0,0,0.05);
            --snake-head: #6c5ce7;
            --snake-body: #a29bfe;
            --food-color: #e74c3c;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: var(--bg);
            color: var(--text);
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.3s, color 0.3s;
            user-select: none;
        }

        .app {
            background: var(--bg-card);
            padding: 2rem;
            border-radius: 20px;
            width: 100%;
            max-width: 480px;
            margin: 1rem;
            border: 1px solid var(--border);
            box-shadow: 0 8px 32px var(--shadow);
            transition: background 0.3s, border-color 0.3s;
        }

        .app-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 1rem;
        }

        .app-header h1 {
            font-size: 1.4rem;
            color: var(--accent);
        }

        .theme-toggle {
            background: var(--toggle-bg);
            border: none;
            width: 44px;
            height: 44px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 1.2rem;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.3s, transform 0.2s;
        }

        .theme-toggle:hover { transform: scale(1.1); }
        [data-theme="dark"] .icon-light { display: none; }
        [data-theme="dark"] .icon-dark { display: inline; }
        [data-theme="light"] .icon-light { display: inline; }
        [data-theme="light"] .icon-dark { display: none; }

        /* Score bar */
        .score-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            gap: 0.5rem;
        }

        .score-box {
            background: var(--bg-input);
            border: 1px solid var(--border);
            border-radius: 10px;
            padding: 0.5rem 1rem;
            text-align: center;
            flex: 1;
            transition: background 0.3s, border-color 0.3s;
        }

        .score-label {
            font-size: 0.65rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .score-value {
            font-size: 1.4rem;
            font-weight: 800;
        }

        .score-value.best {
            color: var(--accent);
        }

        /* Canvas */
        .canvas-wrapper {
            position: relative;
            width: 100%;
            aspect-ratio: 1;
            border-radius: 12px;
            overflow: hidden;
            border: 2px solid var(--border);
            transition: border-color 0.3s;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            background: var(--canvas-bg);
        }

        /* Overlay */
        .overlay {
            position: absolute;
            inset: 0;
            background: rgba(0,0,0,0.7);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 1rem;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }

        .overlay.visible {
            opacity: 1;
            pointer-events: auto;
        }

        .overlay-title {
            font-size: 1.8rem;
            font-weight: 800;
            color: white;
        }

        .overlay-sub {
            color: #ccc;
            font-size: 0.95rem;
        }

        .overlay-score {
            font-size: 2.5rem;
            font-weight: 800;
            color: var(--accent);
        }

        .play-btn {
            padding: 0.8rem 2rem;
            background: var(--accent);
            color: white;
            border: none;
            border-radius: 12px;
            font-size: 1.1rem;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.3s, transform 0.2s;
        }

        .play-btn:hover {
            background: var(--accent-hover);
            transform: translateY(-2px);
        }

        /* Mobile controls */
        .controls {
            display: none;
            grid-template-areas:
                ". up ."
                "left down right";
            grid-template-columns: 1fr 1fr 1fr;
            gap: 0.5rem;
            margin-top: 1rem;
        }

        .ctrl-btn {
            background: var(--bg-input);
            border: 1px solid var(--border);
            color: var(--text);
            border-radius: 12px;
            padding: 1rem;
            font-size: 1.3rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s, transform 0.1s;
            -webkit-tap-highlight-color: transparent;
        }

        .ctrl-btn:active {
            transform: scale(0.92);
            background: var(--accent);
            color: white;
        }

        .ctrl-up { grid-area: up; }
        .ctrl-down { grid-area: down; }
        .ctrl-left { grid-area: left; }
        .ctrl-right { grid-area: right; }

        @media (pointer: coarse) {
            .controls { display: grid; }
        }

        /* Speed select */
        .speed-row {
            display: flex;
            gap: 0.5rem;
            margin-top: 1rem;
            justify-content: center;
        }

        .speed-btn {
            padding: 0.4rem 1rem;
            background: var(--bg-input);
            border: 1px solid var(--border);
            color: var(--text-muted);
            border-radius: 8px;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .speed-btn.active {
            background: var(--accent);
            color: white;
            border-color: var(--accent);
        }

        /* Back link */
        .back-link {
            display: inline-block;
            margin-top: 1rem;
            color: var(--text-muted);
            text-decoration: none;
            font-size: 0.85rem;
            transition: color 0.3s;
            text-align: center;
            width: 100%;
        }

        .back-link:hover { color: var(--accent); }

        @media (max-width: 500px) {
            .app { padding: 1.25rem; margin: 0.5rem; }
            .overlay-title { font-size: 1.4rem; }
        }
    </style>
</head>
<body>
    <div class="app">
        <div class="app-header">
            <h1>Snake</h1>
            <button class="theme-toggle" id="themeToggle" aria-label="Zmien motyw">
                <span class="icon-dark">&#9790;</span>
                <span class="icon-light">&#9728;</span>
            </button>
        </div>

        <div class="score-bar">
            <div class="score-box">
                <div class="score-label">Wynik</div>
                <div class="score-value" id="score">0</div>
            </div>
            <div class="score-box">
                <div class="score-label">Najlepszy</div>
                <div class="score-value best" id="best">0</div>
            </div>
        </div>

        <div class="canvas-wrapper">
            <canvas id="game"></canvas>
            <!-- Start overlay -->
            <div class="overlay visible" id="startOverlay">
                <div class="overlay-title">Snake</div>
                <div class="overlay-sub">Uzywaj strzalek lub WASD</div>
                <button class="play-btn" id="startBtn">Graj</button>
            </div>
            <!-- Game over overlay -->
            <div class="overlay" id="gameOverOverlay">
                <div class="overlay-title">Koniec gry!</div>
                <div class="overlay-sub">Twoj wynik</div>
                <div class="overlay-score" id="finalScore">0</div>
                <button class="play-btn" id="restartBtn">Zagraj ponownie</button>
            </div>
        </div>

        <!-- Mobile controls -->
        <div class="controls" id="mobileControls">
            <button class="ctrl-btn ctrl-up" data-dir="up">&#9650;</button>
            <button class="ctrl-btn ctrl-left" data-dir="left">&#9664;</button>
            <button class="ctrl-btn ctrl-down" data-dir="down">&#9660;</button>
            <button class="ctrl-btn ctrl-right" data-dir="right">&#9654;</button>
        </div>

        <!-- Speed -->
        <div class="speed-row">
            <button class="speed-btn" data-speed="130">Wolno</button>
            <button class="speed-btn active" data-speed="90">Normalnie</button>
            <button class="speed-btn" data-speed="55">Szybko</button>
        </div>

        <a href="../../index.html" class="back-link">&larr; Powrot do portfolio</a>
    </div>

    <script>
        // --- Config ---
        const GRID_SIZE = 20;
        let speed = 90;
        let gameLoop = null;
        let running = false;

        // --- Elements ---
        const canvas = document.getElementById('game');
        const ctx = canvas.getContext('2d');
        const scoreEl = document.getElementById('score');
        const bestEl = document.getElementById('best');
        const startOverlay = document.getElementById('startOverlay');
        const gameOverOverlay = document.getElementById('gameOverOverlay');
        const finalScoreEl = document.getElementById('finalScore');

        // --- Theme ---
        const themeToggle = document.getElementById('themeToggle');
        const savedTheme = localStorage.getItem('snake-theme') || 'dark';
        document.documentElement.setAttribute('data-theme', savedTheme);

        themeToggle.addEventListener('click', () => {
            const current = document.documentElement.getAttribute('data-theme');
            const next = current === 'dark' ? 'light' : 'dark';
            document.documentElement.setAttribute('data-theme', next);
            localStorage.setItem('snake-theme', next);
            if (!running) drawFrame();
        });

        // --- Best score ---
        let bestScore = parseInt(localStorage.getItem('snake-best')) || 0;
        bestEl.textContent = bestScore;

        // --- Game state ---
        let snake, direction, nextDirection, food, score, gameOver;

        function initGame() {
            const mid = Math.floor(GRID_SIZE / 2);
            snake = [
                { x: mid, y: mid },
                { x: mid - 1, y: mid },
                { x: mid - 2, y: mid }
            ];
            direction = 'right';
            nextDirection = 'right';
            score = 0;
            gameOver = false;
            scoreEl.textContent = '0';
            spawnFood();
        }

        function spawnFood() {
            let pos;
            do {
                pos = {
                    x: Math.floor(Math.random() * GRID_SIZE),
                    y: Math.floor(Math.random() * GRID_SIZE)
                };
            } while (snake.some(s => s.x === pos.x && s.y === pos.y));
            food = pos;
        }

        // --- Canvas sizing ---
        function resizeCanvas() {
            const rect = canvas.parentElement.getBoundingClientRect();
            const size = Math.floor(rect.width);
            canvas.width = size;
            canvas.height = size;
            if (!running) drawFrame();
        }

        window.addEventListener('resize', resizeCanvas);

        // --- Drawing ---
        function getCSS(varName) {
            return getComputedStyle(document.documentElement).getPropertyValue(varName).trim();
        }

        function drawFrame() {
            const cellSize = canvas.width / GRID_SIZE;
            ctx.fillStyle = getCSS('--canvas-bg');
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Grid
            ctx.strokeStyle = getCSS('--grid-line');
            ctx.lineWidth = 1;
            for (let i = 1; i < GRID_SIZE; i++) {
                const pos = i * cellSize;
                ctx.beginPath();
                ctx.moveTo(pos, 0);
                ctx.lineTo(pos, canvas.height);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(0, pos);
                ctx.lineTo(canvas.width, pos);
                ctx.stroke();
            }

            if (!snake) return;

            // Food — pulsating circle
            const pulse = 0.8 + 0.2 * Math.sin(Date.now() / 200);
            const foodRadius = (cellSize / 2 - 2) * pulse;
            ctx.fillStyle = getCSS('--food-color');
            ctx.beginPath();
            ctx.arc(
                food.x * cellSize + cellSize / 2,
                food.y * cellSize + cellSize / 2,
                foodRadius, 0, Math.PI * 2
            );
            ctx.fill();

            // Food glow
            ctx.shadowColor = getCSS('--food-color');
            ctx.shadowBlur = 12;
            ctx.fill();
            ctx.shadowBlur = 0;

            // Snake
            snake.forEach((seg, i) => {
                const x = seg.x * cellSize;
                const y = seg.y * cellSize;
                const r = 4;
                const pad = 1;

                if (i === 0) {
                    ctx.fillStyle = getCSS('--snake-head');
                    ctx.shadowColor = getCSS('--snake-head');
                    ctx.shadowBlur = 8;
                } else {
                    const alpha = 1 - (i / snake.length) * 0.5;
                    ctx.fillStyle = getCSS('--snake-body');
                    ctx.globalAlpha = alpha;
                    ctx.shadowBlur = 0;
                }

                ctx.beginPath();
                ctx.roundRect(x + pad, y + pad, cellSize - pad * 2, cellSize - pad * 2, r);
                ctx.fill();
                ctx.globalAlpha = 1;
                ctx.shadowBlur = 0;
            });

            // Eyes on head
            if (snake.length > 0) {
                const head = snake[0];
                const hx = head.x * cellSize + cellSize / 2;
                const hy = head.y * cellSize + cellSize / 2;
                const eyeR = cellSize * 0.1;
                const eyeOffset = cellSize * 0.2;

                ctx.fillStyle = 'white';
                let e1x, e1y, e2x, e2y;

                if (direction === 'right') {
                    e1x = hx + eyeOffset; e1y = hy - eyeOffset;
                    e2x = hx + eyeOffset; e2y = hy + eyeOffset;
                } else if (direction === 'left') {
                    e1x = hx - eyeOffset; e1y = hy - eyeOffset;
                    e2x = hx - eyeOffset; e2y = hy + eyeOffset;
                } else if (direction === 'up') {
                    e1x = hx - eyeOffset; e1y = hy - eyeOffset;
                    e2x = hx + eyeOffset; e2y = hy - eyeOffset;
                } else {
                    e1x = hx - eyeOffset; e1y = hy + eyeOffset;
                    e2x = hx + eyeOffset; e2y = hy + eyeOffset;
                }

                ctx.beginPath();
                ctx.arc(e1x, e1y, eyeR, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(e2x, e2y, eyeR, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // --- Game logic ---
        function update() {
            direction = nextDirection;

            const head = { ...snake[0] };
            if (direction === 'up') head.y--;
            else if (direction === 'down') head.y++;
            else if (direction === 'left') head.x--;
            else if (direction === 'right') head.x++;

            // Wall collision
            if (head.x < 0 || head.x >= GRID_SIZE || head.y < 0 || head.y >= GRID_SIZE) {
                endGame();
                return;
            }

            // Self collision
            if (snake.some(s => s.x === head.x && s.y === head.y)) {
                endGame();
                return;
            }

            snake.unshift(head);

            // Food check
            if (head.x === food.x && head.y === food.y) {
                score++;
                scoreEl.textContent = score;
                spawnFood();
            } else {
                snake.pop();
            }

            drawFrame();
        }

        function endGame() {
            running = false;
            gameOver = true;
            clearInterval(gameLoop);

            if (score > bestScore) {
                bestScore = score;
                localStorage.setItem('snake-best', bestScore);
                bestEl.textContent = bestScore;
            }

            finalScoreEl.textContent = score;
            gameOverOverlay.classList.add('visible');
        }

        function startGame() {
            startOverlay.classList.remove('visible');
            gameOverOverlay.classList.remove('visible');
            initGame();
            drawFrame();
            running = true;
            clearInterval(gameLoop);
            gameLoop = setInterval(update, speed);
        }

        // --- Controls ---
        const dirMap = {
            ArrowUp: 'up', ArrowDown: 'down', ArrowLeft: 'left', ArrowRight: 'right',
            w: 'up', s: 'down', a: 'left', d: 'right',
            W: 'up', S: 'down', A: 'left', D: 'right'
        };

        const opposites = { up: 'down', down: 'up', left: 'right', right: 'left' };

        document.addEventListener('keydown', (e) => {
            const dir = dirMap[e.key];
            if (dir && running) {
                e.preventDefault();
                if (dir !== opposites[direction]) {
                    nextDirection = dir;
                }
            }
        });

        // Mobile controls
        document.querySelectorAll('.ctrl-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const dir = btn.dataset.dir;
                if (dir && running && dir !== opposites[direction]) {
                    nextDirection = dir;
                }
            });
        });

        // Swipe support
        let touchStartX = 0, touchStartY = 0;

        canvas.addEventListener('touchstart', (e) => {
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
        }, { passive: true });

        canvas.addEventListener('touchend', (e) => {
            if (!running) return;
            const dx = e.changedTouches[0].clientX - touchStartX;
            const dy = e.changedTouches[0].clientY - touchStartY;

            if (Math.abs(dx) < 20 && Math.abs(dy) < 20) return;

            let dir;
            if (Math.abs(dx) > Math.abs(dy)) {
                dir = dx > 0 ? 'right' : 'left';
            } else {
                dir = dy > 0 ? 'down' : 'up';
            }

            if (dir !== opposites[direction]) {
                nextDirection = dir;
            }
        }, { passive: true });

        // Speed buttons
        document.querySelectorAll('.speed-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.speed-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                speed = parseInt(btn.dataset.speed);
                if (running) {
                    clearInterval(gameLoop);
                    gameLoop = setInterval(update, speed);
                }
            });
        });

        // Start / Restart
        document.getElementById('startBtn').addEventListener('click', startGame);
        document.getElementById('restartBtn').addEventListener('click', startGame);

        // Init
        initGame();
        resizeCanvas();
        drawFrame();
    </script>
</body>
</html>
